"""
Celery tasks for malware scanning operations.
"""
import os
import logging
from celery import shared_task
from django.core.files.storage import default_storage
from django.contrib.auth import get_user_model

from api.services.malware_scanning_service import malware_scanning_service
from api.models import MalwareScanLog

User = get_user_model()
logger = logging.getLogger(__name__)


@shared_task(
    bind=True,
    max_retries=2,
    default_retry_delay=300,  # 5 minutes
    retry_backoff=True
)
def scan_uploaded_file_async(self, file_path, user_id, file_info):
    """
    Asynchronously scan an uploaded file for malware.
    
    This task is used for post-upload scanning that doesn't block
    the user experience.
    
    Args:
        file_path: Path to the uploaded file in storage
        user_id: ID of the user who uploaded the file
        file_info: Dictionary with file metadata
        
    Returns:
        Dict with scan results
    """
    try:
        # Get user
        user = User.objects.get(id=user_id)
        
        # Check if file still exists
        if not default_storage.exists(file_path):
            logger.warning(f"File not found for async scan: {file_path}")
            return {
                'success': False,
                'error': 'File not found',
                'file_path': file_path
            }
        
        # Get temporary file for scanning
        temp_file_path = None
        try:
            # Download file from storage to temporary location
            with default_storage.open(file_path, 'rb') as stored_file:
                import tempfile
                temp_fd, temp_file_path = tempfile.mkstemp()
                
                with os.fdopen(temp_fd, 'wb') as temp_file:
                    # Copy file content
                    for chunk in stored_file.chunks():
                        temp_file.write(chunk)
            
            # Create a mock uploaded file for scanning
            class MockUploadedFile:
                def __init__(self, file_path, name, size):
                    self.file_path = file_path
                    self.name = name
                    self.size = size
                    self._file = None
                
                def chunks(self):
                    with open(self.file_path, 'rb') as f:
                        while True:
                            chunk = f.read(8192)
                            if not chunk:
                                break
                            yield chunk
                
                def read(self, size=-1):
                    with open(self.file_path, 'rb') as f:
                        return f.read(size)
                
                def seek(self, pos):
                    # For compatibility - file operations handle this
                    pass
            
            mock_file = MockUploadedFile(
                temp_file_path,
                file_info.get('original_name', 'unknown'),
                file_info.get('size', 0)
            )
            
            # Perform malware scan
            scan_results = malware_scanning_service.scan_file(mock_file)
            is_clean, threats = malware_scanning_service.is_file_clean(scan_results)
            
            # Log scan results
            MalwareScanLog.objects.create(
                user=user,
                file_hash=file_info.get('hash', ''),
                file_name=file_info.get('original_name', 'unknown'),
                file_size=file_info.get('size', 0),
                mime_type=file_info.get('mime_type', 'unknown'),
                is_clean=is_clean,
                scan_results={k: v.to_dict() for k, v in scan_results.items()},
                threats_detected=threats,
                scanners_used=list(scan_results.keys()),
                total_scan_time=sum(r.scan_time for r in scan_results.values())
            )
            
            # If file is infected, quarantine it
            if not is_clean:
                quarantine_result = quarantine_infected_file.delay(file_path, user_id, threats)
                logger.warning(
                    f"Infected file detected in async scan: {file_path}",
                    extra={
                        'user_id': user_id,
                        'threats': threats,
                        'quarantine_task_id': quarantine_result.id
                    }
                )
            
            logger.info(
                f"Async malware scan completed for {file_path}",
                extra={
                    'user_id': user_id,
                    'is_clean': is_clean,
                    'scanners': list(scan_results.keys()),
                    'scan_time': sum(r.scan_time for r in scan_results.values())
                }
            )
            
            return {
                'success': True,
                'is_clean': is_clean,
                'threats': threats,
                'scan_results': {k: v.to_dict() for k, v in scan_results.items()},
                'file_path': file_path
            }
            
        finally:
            # Clean up temporary file
            if temp_file_path and os.path.exists(temp_file_path):
                try:
                    os.unlink(temp_file_path)
                except OSError:
                    pass
        
    except User.DoesNotExist:
        logger.error(f"User {user_id} not found for async malware scan")
        return {
            'success': False,
            'error': 'User not found',
            'file_path': file_path
        }
    
    except Exception as e:
        logger.error(f"Error in async malware scan for {file_path}: {e}")
        
        # Retry if we haven't exceeded max retries
        if self.request.retries < self.max_retries:
            raise self.retry(exc=e)
        
        return {
            'success': False,
            'error': str(e),
            'file_path': file_path
        }


@shared_task
def quarantine_infected_file(file_path, user_id, threats):
    """
    Quarantine an infected file by moving it to a secure location.
    
    Args:
        file_path: Path to the infected file
        user_id: ID of the user who uploaded the file
        threats: List of threats detected
        
    Returns:
        Dict with quarantine results
    """
    try:
        # Get user
        user = User.objects.get(id=user_id)
        
        # Check if file exists
        if not default_storage.exists(file_path):
            logger.warning(f"File not found for quarantine: {file_path}")
            return {
                'success': False,
                'error': 'File not found',
                'file_path': file_path
            }
        
        # Create quarantine directory structure
        import datetime
        quarantine_dir = os.path.join(
            'quarantine',
            str(user_id),
            datetime.datetime.now().strftime('%Y/%m/%d')
        )
        
        # Generate quarantine filename
        original_name = os.path.basename(file_path)
        quarantine_filename = f"{datetime.datetime.now().strftime('%H%M%S')}_{original_name}"
        quarantine_path = os.path.join(quarantine_dir, quarantine_filename)
        
        # Move file to quarantine
        with default_storage.open(file_path, 'rb') as source_file:
            quarantine_full_path = default_storage.save(quarantine_path, source_file)
        
        # Delete original file
        default_storage.delete(file_path)
        
        # Create metadata file with threat information
        metadata = {
            'original_path': file_path,
            'quarantine_date': datetime.datetime.now().isoformat(),
            'user_id': user_id,
            'threats': threats,
            'quarantine_reason': 'Malware detected during scan'
        }
        
        metadata_content = json.dumps(metadata, indent=2)
        metadata_path = f"{quarantine_full_path}.metadata"
        default_storage.save(
            metadata_path,
            ContentFile(metadata_content.encode('utf-8'))
        )
        
        logger.warning(
            f"File quarantined due to malware: {file_path} -> {quarantine_full_path}",
            extra={
                'user_id': user_id,
                'threats': threats,
                'original_path': file_path,
                'quarantine_path': quarantine_full_path
            }
        )
        
        # Optionally, notify user about quarantine
        notify_user_of_quarantine.delay(user_id, original_name, threats)
        
        return {
            'success': True,
            'quarantine_path': quarantine_full_path,
            'metadata_path': metadata_path,
            'original_path': file_path
        }
        
    except User.DoesNotExist:
        logger.error(f"User {user_id} not found for file quarantine")
        return {
            'success': False,
            'error': 'User not found',
            'file_path': file_path
        }
    
    except Exception as e:
        logger.error(f"Error quarantining file {file_path}: {e}")
        return {
            'success': False,
            'error': str(e),
            'file_path': file_path
        }


@shared_task
def notify_user_of_quarantine(user_id, filename, threats):
    """
    Notify user that their file has been quarantined.
    
    Args:
        user_id: ID of the user
        filename: Name of the quarantined file
        threats: List of threats detected
    """
    try:
        from api.models import Notification
        
        user = User.objects.get(id=user_id)
        
        threats_text = ", ".join([
            threat.get('threat', 'Unknown threat')
            for threat in threats[:3]  # Show first 3 threats
        ])
        
        if len(threats) > 3:
            threats_text += f" and {len(threats) - 3} more"
        
        # Create notification
        Notification.objects.create(
            user=user,
            type='security_alert',
            title='File Quarantined for Security',
            message=f'Your uploaded file "{filename}" has been quarantined due to security concerns. '
                   f'Threats detected: {threats_text}. Please contact support if you believe this is an error.',
            channel='in_app',
            priority='high',
            data={
                'filename': filename,
                'threats': threats,
                'action_required': False,
                'quarantine_date': datetime.datetime.now().isoformat()
            }
        )
        
        logger.info(f"Quarantine notification sent to user {user_id} for file {filename}")
        
    except User.DoesNotExist:
        logger.error(f"User {user_id} not found for quarantine notification")
    except Exception as e:
        logger.error(f"Error sending quarantine notification to user {user_id}: {e}")


@shared_task
def cleanup_old_quarantine_files():
    """
    Clean up old quarantined files (older than 30 days).
    Runs daily via cron.
    """
    try:
        import datetime
        from django.conf import settings
        
        cutoff_date = datetime.datetime.now() - datetime.timedelta(days=30)
        quarantine_base = 'quarantine'
        
        if not default_storage.exists(quarantine_base):
            return {'message': 'No quarantine directory found'}
        
        deleted_count = 0
        
        # List quarantine directories
        dirs, files = default_storage.listdir(quarantine_base)
        
        for user_dir in dirs:
            user_quarantine_path = os.path.join(quarantine_base, user_dir)
            
            try:
                # Check subdirectories (year/month/day structure)
                year_dirs, _ = default_storage.listdir(user_quarantine_path)
                
                for year_dir in year_dirs:
                    year_path = os.path.join(user_quarantine_path, year_dir)
                    month_dirs, _ = default_storage.listdir(year_path)
                    
                    for month_dir in month_dirs:
                        month_path = os.path.join(year_path, month_dir)
                        day_dirs, _ = default_storage.listdir(month_path)
                        
                        for day_dir in day_dirs:
                            day_path = os.path.join(month_path, day_dir)
                            
                            # Parse date from path
                            try:
                                dir_date = datetime.datetime.strptime(
                                    f"{year_dir}/{month_dir}/{day_dir}",
                                    "%Y/%m/%d"
                                )
                                
                                if dir_date < cutoff_date:
                                    # Delete all files in this directory
                                    _, files_to_delete = default_storage.listdir(day_path)
                                    
                                    for file_to_delete in files_to_delete:
                                        file_path = os.path.join(day_path, file_to_delete)
                                        default_storage.delete(file_path)
                                        deleted_count += 1
                                    
                                    logger.info(f"Cleaned up quarantine directory: {day_path}")
                                    
                            except ValueError:
                                # Invalid date format, skip
                                continue
                                
            except Exception as e:
                logger.error(f"Error cleaning quarantine directory {user_dir}: {e}")
                continue
        
        logger.info(f"Quarantine cleanup completed. Deleted {deleted_count} files.")
        
        return {
            'success': True,
            'deleted_count': deleted_count,
            'cutoff_date': cutoff_date.isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error during quarantine cleanup: {e}")
        return {
            'success': False,
            'error': str(e)
        }


@shared_task
def update_virus_definitions():
    """
    Update virus definitions for ClamAV.
    Should be run daily to keep malware detection up to date.
    """
    try:
        import subprocess
        
        # Update ClamAV database
        result = subprocess.run(
            ['freshclam'],
            capture_output=True,
            text=True,
            timeout=300  # 5 minutes timeout
        )
        
        if result.returncode == 0:
            logger.info("ClamAV virus definitions updated successfully")
            return {
                'success': True,
                'output': result.stdout,
                'message': 'Virus definitions updated'
            }
        else:
            logger.error(f"Failed to update ClamAV definitions: {result.stderr}")
            return {
                'success': False,
                'error': result.stderr,
                'returncode': result.returncode
            }
            
    except subprocess.TimeoutExpired:
        logger.error("Virus definition update timed out")
        return {
            'success': False,
            'error': 'Update process timed out'
        }
    except FileNotFoundError:
        logger.warning("freshclam command not found - ClamAV may not be installed")
        return {
            'success': False,
            'error': 'freshclam command not found'
        }
    except Exception as e:
        logger.error(f"Error updating virus definitions: {e}")
        return {
            'success': False,
            'error': str(e)
        }


# Import required modules
import json
from django.core.files.base import ContentFile
import datetime