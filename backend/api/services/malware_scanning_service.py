"""
Malware scanning service integrating ClamAV and VirusTotal.

This service provides comprehensive malware detection for uploaded files.
"""

import hashlib
import logging
import os
import subprocess
import time
from datetime import timedelta
from typing import Any, Dict, Optional, Tuple

import requests
from django.conf import settings
from django.core.cache import cache
from django.utils import timezone
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

logger = logging.getLogger(__name__)


class MalwareScanResult:
    """Represents the result of a malware scan."""

    def __init__(
        self,
        is_clean: bool,
        scanner: str,
        scan_time: float = 0.0,
        details: Optional[Dict[str, Any]] = None,
        threats: Optional[list] = None,
    ):
        self.is_clean = is_clean
        self.scanner = scanner
        self.scan_time = scan_time
        self.details = details or {}
        self.threats = threats or []
        self.scanned_at = timezone.now()

    def to_dict(self) -> Dict[str, Any]:
        """Convert scan result to dictionary."""
        return {
            "is_clean": self.is_clean,
            "scanner": self.scanner,
            "scan_time": self.scan_time,
            "details": self.details,
            "threats": self.threats,
            "scanned_at": self.scanned_at.isoformat(),
        }


class ClamAVScanner:
    """ClamAV antivirus scanner integration."""

    def __init__(self):
        self.enabled = False
        self.clamd_socket = getattr(settings, "CLAMAV_SOCKET_PATH", "/tmp/clamd.socket")
        self.clamscan_path = getattr(settings, "CLAMAV_CLAMSCAN_PATH", "clamscan")

        # Check if ClamAV is available
        self._check_availability()

    def _check_availability(self):
        """Check if ClamAV is available and accessible."""
        try:
            # Try using clamd socket first
            if os.path.exists(self.clamd_socket):
                self.enabled = True
                self.use_daemon = True
                logger.info("ClamAV daemon found and available")
                return

            # Fallback to clamscan binary
            result = subprocess.run(
                [self.clamscan_path, "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                self.enabled = True
                self.use_daemon = False
                logger.info("ClamAV clamscan binary found and available")
            else:
                logger.warning("ClamAV clamscan binary not working properly")
        except (FileNotFoundError, subprocess.TimeoutExpired, Exception) as e:
            logger.warning(f"ClamAV not available: {e}")

    def scan_file(self, file_path: str) -> MalwareScanResult:
        """
        Scan file with ClamAV.

        Args:
            file_path: Path to file to scan

        Returns:
            MalwareScanResult: Scan results
        """
        if not self.enabled:
            return MalwareScanResult(
                is_clean=True,
                scanner="clamav",
                details={"error": "ClamAV not available"},
            )

        start_time = time.time()

        try:
            if self.use_daemon:
                return self._scan_with_daemon(file_path, start_time)
            else:
                return self._scan_with_binary(file_path, start_time)
        except Exception as e:
            logger.error(f"ClamAV scan error: {e}")
            return MalwareScanResult(
                is_clean=False,
                scanner="clamav",
                scan_time=time.time() - start_time,
                details={"error": str(e)},
            )

    def _scan_with_daemon(self, file_path: str, start_time: float) -> MalwareScanResult:
        """Scan using clamd daemon."""
        try:
            import pyclamd

            # Connect to daemon
            cd = pyclamd.ClamdUnixSocket(self.clamd_socket)

            # Ping daemon
            if not cd.ping():
                raise Exception("ClamAV daemon not responding")

            # Scan file
            scan_result = cd.scan_file(file_path)
            scan_time = time.time() - start_time

            if scan_result is None:
                # File is clean
                return MalwareScanResult(
                    is_clean=True,
                    scanner="clamav_daemon",
                    scan_time=scan_time,
                    details={"method": "daemon"},
                )
            else:
                # Threat found
                threats = []
                for file, threat in scan_result.items():
                    threats.append(
                        {
                            "file": file,
                            "threat": (
                                threat[1] if isinstance(threat, tuple) else str(threat)
                            ),
                        }
                    )

                return MalwareScanResult(
                    is_clean=False,
                    scanner="clamav_daemon",
                    scan_time=scan_time,
                    details={"method": "daemon"},
                    threats=threats,
                )

        except ImportError:
            logger.warning("pyclamd not installed, falling back to binary")
            return self._scan_with_binary(file_path, start_time)

    def _scan_with_binary(self, file_path: str, start_time: float) -> MalwareScanResult:
        """Scan using clamscan binary."""
        try:
            result = subprocess.run(
                [self.clamscan_path, "--stdout", "--no-summary", file_path],
                capture_output=True,
                text=True,
                timeout=60,  # 1 minute timeout
            )

            scan_time = time.time() - start_time

            if result.returncode == 0:
                # File is clean
                return MalwareScanResult(
                    is_clean=True,
                    scanner="clamav_binary",
                    scan_time=scan_time,
                    details={"method": "binary", "output": result.stdout.strip()},
                )
            elif result.returncode == 1:
                # Threat found
                threats = []
                for line in result.stdout.strip().split("\n"):
                    if "FOUND" in line:
                        parts = line.split(": ")
                        if len(parts) >= 2:
                            threats.append(
                                {
                                    "file": parts[0],
                                    "threat": parts[1].replace(" FOUND", ""),
                                }
                            )

                return MalwareScanResult(
                    is_clean=False,
                    scanner="clamav_binary",
                    scan_time=scan_time,
                    details={"method": "binary", "output": result.stdout.strip()},
                    threats=threats,
                )
            else:
                # Error occurred
                raise Exception(f"ClamAV scan failed: {result.stderr}")

        except subprocess.TimeoutExpired:
            raise Exception("ClamAV scan timed out")


class VirusTotalScanner:
    """VirusTotal API scanner integration."""

    def __init__(self):
        self.api_key = getattr(settings, "VIRUSTOTAL_API_KEY", None)
        self.enabled = bool(self.api_key)
        self.base_url = "https://www.virustotal.com/vtapi/v2"
        self._session = None
        self._setup_session()

        if not self.enabled:
            logger.warning("VirusTotal API key not configured")
    
    def _setup_session(self):
        """Setup requests session with connection pooling and retry logic."""
        self._session = requests.Session()
        
        # Configure retry strategy
        retry_strategy = Retry(
            total=3,
            backoff_factor=2,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "POST"]
        )
        
        # Configure HTTP adapter with connection pooling
        adapter = HTTPAdapter(
            pool_connections=5,
            pool_maxsize=10,
            max_retries=retry_strategy,
            pool_block=False
        )
        
        self._session.mount("https://", adapter)
        self._session.mount("http://", adapter)

    def scan_file_hash(self, file_hash: str) -> MalwareScanResult:
        """
        Scan file by hash using VirusTotal.

        Args:
            file_hash: SHA-256 hash of the file

        Returns:
            MalwareScanResult: Scan results
        """
        if not self.enabled:
            return MalwareScanResult(
                is_clean=True,
                scanner="virustotal",
                details={"error": "VirusTotal API key not configured"},
            )

        start_time = time.time()

        try:
            # Check if file is already scanned
            params = {"apikey": self.api_key, "resource": file_hash}

            response = self._session.get(
                f"{self.base_url}/file/report", params=params, timeout=30
            )

            scan_time = time.time() - start_time

            if response.status_code != 200:
                raise Exception(f"VirusTotal API error: {response.status_code}")

            data = response.json()

            if data["response_code"] == 0:
                # File not found in VirusTotal database
                return MalwareScanResult(
                    is_clean=True,
                    scanner="virustotal",
                    scan_time=scan_time,
                    details={
                        "response_code": 0,
                        "message": "File not found in VirusTotal database",
                    },
                )
            elif data["response_code"] == 1:
                # File found, check results
                positives = data.get("positives", 0)
                total = data.get("total", 0)

                threats = []
                if positives > 0 and "scans" in data:
                    for engine, result in data["scans"].items():
                        if result["detected"]:
                            threats.append(
                                {
                                    "engine": engine,
                                    "threat": result.get("result", "Unknown"),
                                    "version": result.get("version", "Unknown"),
                                }
                            )

                return MalwareScanResult(
                    is_clean=(positives == 0),
                    scanner="virustotal",
                    scan_time=scan_time,
                    details={
                        "positives": positives,
                        "total": total,
                        "scan_date": data.get("scan_date"),
                        "permalink": data.get("permalink"),
                    },
                    threats=threats,
                )
            else:
                raise Exception(f"Unexpected VirusTotal response: {data}")

        except Exception as e:
            logger.error(f"VirusTotal scan error: {e}")
            return MalwareScanResult(
                is_clean=False,
                scanner="virustotal",
                scan_time=time.time() - start_time,
                details={"error": str(e)},
            )

    def upload_and_scan(self, file_path: str) -> MalwareScanResult:
        """
        Upload file to VirusTotal for scanning.

        Args:
            file_path: Path to file to upload and scan

        Returns:
            MalwareScanResult: Upload results (scan results need to be checked later)
        """
        if not self.enabled:
            return MalwareScanResult(
                is_clean=True,
                scanner="virustotal",
                details={"error": "VirusTotal API key not configured"},
            )

        start_time = time.time()

        try:
            with open(file_path, "rb") as f:
                files = {"file": f}
                params = {"apikey": self.api_key}

                response = self._session.post(
                    f"{self.base_url}/file/scan", files=files, params=params, timeout=60
                )

            scan_time = time.time() - start_time

            if response.status_code != 200:
                raise Exception(f"VirusTotal upload error: {response.status_code}")

            data = response.json()

            return MalwareScanResult(
                is_clean=True,  # Upload successful, need to check results later
                scanner="virustotal_upload",
                scan_time=scan_time,
                details={
                    "scan_id": data.get("scan_id"),
                    "permalink": data.get("permalink"),
                    "message": "File uploaded for scanning",
                },
            )

        except Exception as e:
            logger.error(f"VirusTotal upload error: {e}")
            return MalwareScanResult(
                is_clean=False,
                scanner="virustotal_upload",
                scan_time=time.time() - start_time,
                details={"error": str(e)},
            )


class MalwareScanningService:
    """
    Main malware scanning service that coordinates multiple scanners.
    """

    def __init__(self):
        self.clamav = ClamAVScanner()
        self.virustotal = VirusTotalScanner()
        self.cache_timeout = getattr(
            settings, "MALWARE_SCAN_CACHE_TIMEOUT", 24 * 60 * 60
        )  # 24 hours

    def scan_file(
        self, uploaded_file, cache_results: bool = True
    ) -> Dict[str, MalwareScanResult]:
        """
        Scan uploaded file with all available scanners.

        Args:
            uploaded_file: Django UploadedFile instance
            cache_results: Whether to cache scan results

        Returns:
            Dict[str, MalwareScanResult]: Results from each scanner
        """
        # Generate file hash for caching and VirusTotal
        file_hash = self._generate_file_hash(uploaded_file)

        # Check cache first
        if cache_results:
            cached_results = self._get_cached_results(file_hash)
            if cached_results:
                logger.info(
                    f"Using cached malware scan results for hash {file_hash[:8]}"
                )
                return cached_results

        results = {}

        # Save file temporarily for scanning
        temp_file_path = self._save_temp_file(uploaded_file, file_hash)

        try:
            # Scan with ClamAV if available
            if self.clamav.enabled:
                logger.info(f"Scanning file with ClamAV: {file_hash[:8]}")
                results["clamav"] = self.clamav.scan_file(temp_file_path)

            # Scan with VirusTotal if available
            if self.virustotal.enabled:
                logger.info(f"Scanning file hash with VirusTotal: {file_hash[:8]}")
                results["virustotal"] = self.virustotal.scan_file_hash(file_hash)

            # If no scanners available, use basic pattern matching
            if not results:
                logger.warning(
                    "No malware scanners available, using basic pattern matching"
                )
                results["basic"] = self._basic_pattern_scan(uploaded_file)

            # Cache results
            if cache_results and results:
                self._cache_results(file_hash, results)

            return results

        finally:
            # Clean up temporary file
            if os.path.exists(temp_file_path):
                try:
                    os.unlink(temp_file_path)
                except OSError:
                    pass

    def is_file_clean(
        self, scan_results: Dict[str, MalwareScanResult]
    ) -> Tuple[bool, list]:
        """
        Determine if file is clean based on scan results.

        Args:
            scan_results: Results from scan_file()

        Returns:
            Tuple[bool, list]: (is_clean, list_of_threats)
        """
        threats = []

        for scanner, result in scan_results.items():
            if not result.is_clean:
                threats.extend(result.threats)

                # If any scanner finds threats, file is not clean
                return False, threats

        return True, threats

    def _generate_file_hash(self, uploaded_file) -> str:
        """Generate SHA-256 hash of uploaded file."""
        uploaded_file.seek(0)
        file_hash = hashlib.sha256()

        for chunk in uploaded_file.chunks():
            file_hash.update(chunk)

        uploaded_file.seek(0)
        return file_hash.hexdigest()

    def _save_temp_file(self, uploaded_file, file_hash: str) -> str:
        """Save uploaded file temporarily for scanning."""
        import tempfile

        temp_dir = getattr(settings, "MALWARE_SCAN_TEMP_DIR", tempfile.gettempdir())
        temp_file_path = os.path.join(temp_dir, f"scan_{file_hash[:16]}")

        uploaded_file.seek(0)
        with open(temp_file_path, "wb") as temp_file:
            for chunk in uploaded_file.chunks():
                temp_file.write(chunk)

        uploaded_file.seek(0)
        return temp_file_path

    def _get_cached_results(
        self, file_hash: str
    ) -> Optional[Dict[str, MalwareScanResult]]:
        """Get cached scan results."""
        cache_key = f"malware_scan:{file_hash}"
        cached_data = cache.get(cache_key)

        if cached_data:
            # Convert back to MalwareScanResult objects
            results = {}
            for scanner, data in cached_data.items():
                results[scanner] = MalwareScanResult(
                    is_clean=data["is_clean"],
                    scanner=data["scanner"],
                    scan_time=data["scan_time"],
                    details=data["details"],
                    threats=data["threats"],
                )
            return results

        return None

    def _cache_results(self, file_hash: str, results: Dict[str, MalwareScanResult]):
        """Cache scan results."""
        cache_key = f"malware_scan:{file_hash}"
        cache_data = {}

        for scanner, result in results.items():
            cache_data[scanner] = result.to_dict()

        cache.set(cache_key, cache_data, self.cache_timeout)

    def _basic_pattern_scan(self, uploaded_file) -> MalwareScanResult:
        """Basic pattern matching scan as fallback."""
        start_time = time.time()

        suspicious_patterns = [
            b"<script",
            b"eval(",
            b"exec(",
            b"system(",
            b"<%",
            b"<?php",
            b"javascript:",
            b"vbscript:",
            b"onload=",
            b"onerror=",
            b"iframe",
            b"embed",
            b"object",
        ]

        uploaded_file.seek(0)
        content = uploaded_file.read(2048)  # Check first 2KB
        uploaded_file.seek(0)

        threats = []
        for pattern in suspicious_patterns:
            if pattern in content.lower():
                threats.append(
                    {
                        "pattern": pattern.decode("utf-8", errors="ignore"),
                        "threat": "Suspicious pattern detected",
                    }
                )

        return MalwareScanResult(
            is_clean=(len(threats) == 0),
            scanner="basic_pattern",
            scan_time=time.time() - start_time,
            details={"patterns_checked": len(suspicious_patterns)},
            threats=threats,
        )


# Global service instance
malware_scanning_service = MalwareScanningService()
